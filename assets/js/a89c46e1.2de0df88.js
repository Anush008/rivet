"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7241],{6593:(e,t,o)=>{o.d(t,{Zo:()=>c,kt:()=>f});var n=o(1644);function l(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function a(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){l(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function i(e,t){if(null==e)return{};var o,n,l=function(e,t){if(null==e)return{};var o,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||(l[o]=e[o]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(l[o]=e[o])}return l}var s=n.createContext({}),d=function(e){var t=n.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):a(a({},t),e)),o},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var o=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=d(o),h=l,f=p["".concat(s,".").concat(h)]||p[h]||u[h]||r;return o?n.createElement(f,a(a({ref:t},c),{},{components:o})):n.createElement(f,a({ref:t},c))}));function f(e,t){var o=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=o.length,a=new Array(r);a[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[p]="string"==typeof e?e:l,a[1]=i;for(var d=2;d<r;d++)a[d]=o[d];return n.createElement.apply(null,a)}return n.createElement.apply(null,o)}h.displayName="MDXCreateElement"},6610:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var n=o(373),l=(o(1644),o(6593));const r={},a="Control Flow",i={unversionedId:"user-guide/control-flow",id:"user-guide/control-flow",title:"Control Flow",description:"The flow of data in Rivet (and the control of that flow) is handled in two passes on the graph of nodes.",source:"@site/docs/user-guide/control-flow.md",sourceDirName:"user-guide",slug:"/user-guide/control-flow",permalink:"/docs/user-guide/control-flow",draft:!1,editUrl:"https://github.com/ironclad/rivet/tree/main/packages/docs/docs/user-guide/control-flow.md",tags:[],version:"current",frontMatter:{},sidebar:"userGuide",previous:{title:"Data Types",permalink:"/docs/user-guide/data-types"},next:{title:"Loops",permalink:"/docs/user-guide/loops"}},s={},d=[{value:"First Pass: Topological Sort &amp; Entry Points",id:"first-pass-topological-sort--entry-points",level:2},{value:"Second Pass: Execution",id:"second-pass-execution",level:2},{value:"Control Flow Exclusions",id:"control-flow-exclusions",level:3},{value:"Control Flow Excluded Consumers",id:"control-flow-excluded-consumers",level:3},{value:"Loop Controller",id:"loop-controller",level:3},{value:"See Also",id:"see-also",level:2}],c={toc:d},p="wrapper";function u(e){let{components:t,...o}=e;return(0,l.kt)(p,(0,n.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"control-flow"},"Control Flow"),(0,l.kt)("p",null,"The flow of data in Rivet (and the control of that flow) is handled in two passes on the graph of nodes."),(0,l.kt)("h2",{id:"first-pass-topological-sort--entry-points"},"First Pass: Topological Sort & Entry Points"),(0,l.kt)("p",null,'The first pass over nodes works on a topological sort basis. Rivet will find all nodes with no nodes that depend on them. These nodes are considered the "output nodes" of the graph.'),(0,l.kt)("p",null,'Rivet will then find all nodes that depend on the output nodes, and so on, adding the node to a "needs to be processed" list.'),(0,l.kt)("p",null,"Should a cycle be encountered at this point, Rivet will proceed as normal."),(0,l.kt)("p",null,'During the first pass, all nodes that have no dependencies (no data flowing into them) will be marked as "input nodes".'),(0,l.kt)("h2",{id:"second-pass-execution"},"Second Pass: Execution"),(0,l.kt)("p",null,"Starting at the input nodes marked in the first pass, rivet will execute all pending\nnodes in ",(0,l.kt)("strong",{parentName:"p"},"parallel"),"."),(0,l.kt)("p",null,"Every time one of the nodes that is currently executing finishes, it will check to see if any of the nodes that depend on it are ready to be executed. If so, it will execute them in parallel with any other currently-executing node."),(0,l.kt)("p",null,"A node is defined as ready to execute if all of its dependencies have been satisfied. A dependency is satisfied if the node it depends on has finished executing and has a value to pass to the dependent node."),(0,l.kt)("h3",{id:"control-flow-exclusions"},"Control Flow Exclusions"),(0,l.kt)("p",null,"What happens when an If node is encountered, and the output of the If node should not run? In this case, the output of the If node is the special ",(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded")," value. If this value is passed into any node, then that node will not execute."),(0,l.kt)("p",null,"Then, every dependent node of the node that returned ",(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded")," will also return ",(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded"),', and so on. In this respect, control flow exclusion "spreads" to every dependent node after the value has been returned.'),(0,l.kt)("p",null,"Many nodes can return a ",(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded")," value, such as a ",(0,l.kt)("a",{parentName:"p",href:"/docs/node-reference/match"},"Match Node")," (for branches that do not match), and an ",(0,l.kt)("a",{parentName:"p",href:"/docs/node-reference/extract-object-path"},"Extract Object Path Node")," (for when the input path is invalid for a given object)."),(0,l.kt)("h3",{id:"control-flow-excluded-consumers"},"Control Flow Excluded Consumers"),(0,l.kt)("p",null,'Certain types of nodes are registered as able to "consume" a ',(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded")," value. This means that when the node encounters this value, it will actually run with the actual ",(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded"),' value. This allows certain nodes to "break out" of the spreading of ',(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded")," values."),(0,l.kt)("p",null,"Nodes that can consume ",(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded")," values are:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"/docs/node-reference/if-else"},"If/Else")," - If the ",(0,l.kt)("inlineCode",{parentName:"li"},"control-flow-excluded")," is passed into the ",(0,l.kt)("inlineCode",{parentName:"li"},"If")," port, then the ",(0,l.kt)("inlineCode",{parentName:"li"},"Else")," value will be passed through instead. If the ",(0,l.kt)("inlineCode",{parentName:"li"},"Else")," value is not connected, then the result will again be ",(0,l.kt)("inlineCode",{parentName:"li"},"control-flow-excluded"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"/docs/node-reference/coalesce"},"Coalesce")," - ",(0,l.kt)("inlineCode",{parentName:"li"},"control-flow-excluded"),' will be considered "falsey" for the sake of the Coalesce node. The values will be skipped over, and subsequent truthy values connected to the Coalesce node will be passed through instead.'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"/docs/node-reference/race-inputs"},"Race Inputs")," - If one of the branches passed into the Race Inputs node returns ",(0,l.kt)("inlineCode",{parentName:"li"},"control-flow-excluded"),", then that branch will simply be not considered for the race. Other branches may still execute and return a value, which will be passed through the output of the Race Inputs."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"/docs/node-reference/graph-output"},"Graph Output")," - A Graph Output's ",(0,l.kt)("inlineCode",{parentName:"li"},"control-flow-excluded")," may pass out of the graph to become one of the outputs for a ",(0,l.kt)("a",{parentName:"li",href:"/docs/node-reference/subgraph"},"Subgraph")," node. This way, some of the outputs of a Subgraph may not run, and others may run."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"/docs/node-reference/loop-controller"},"Loop Controller")," - A loop controller needs to consume ",(0,l.kt)("inlineCode",{parentName:"li"},"control-flow-excluded")," values in order to run multiple times. Additionally, passing a ",(0,l.kt)("inlineCode",{parentName:"li"},"control-flow-excluded")," to the ",(0,l.kt)("inlineCode",{parentName:"li"},"continue"),' port counts as a "successful" iteration of the loop, and will cause the loop to run again.')),(0,l.kt)("h3",{id:"loop-controller"},"Loop Controller"),(0,l.kt)("p",null,"The loop controller is special, however, in particular its ",(0,l.kt)("inlineCode",{parentName:"p"},"Break")," port. The ",(0,l.kt)("inlineCode",{parentName:"p"},"Break")," port will not pass a ",(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded")," value to the next node\nuntil the loop has finished executing. Otherwise, the loop controller itself could not run multiple times before finally passing a value to the next node."),(0,l.kt)("p",null,"If any other input port to the loop controller receives a ",(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded")," value, then the loop controller will not run again, and will pass the ",(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded")," value to the node connected to ",(0,l.kt)("inlineCode",{parentName:"p"},"Break"),". Thus, it is important to use an ",(0,l.kt)("a",{parentName:"p",href:"/docs/node-reference/if-else"},"If/Else")," or ",(0,l.kt)("a",{parentName:"p",href:"/docs/node-reference/coalesce"},"Coalesce"),' node inside your loop as a "null check" to make sure the loop controller never receieves a ',(0,l.kt)("inlineCode",{parentName:"p"},"control-flow-excluded")," value unless you want it to."),(0,l.kt)("h2",{id:"see-also"},"See Also"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://github.com/Ironclad/rivet/blob/main/packages/core/src/model/GraphProcessor.ts"},(0,l.kt)("inlineCode",{parentName:"a"},"GraphProcessor.ts")))))}u.isMDXComponent=!0}}]);